# API Reference

## yapapi

Golem Python API.

#### get\_version

```python
get_version() -> str
```

**Returns**:

the version of the yapapi library package

#### windows\_event\_loop\_fix

```python
windows_event_loop_fix()
```

Set up asyncio to use ProactorEventLoop implementation for new event loops on Windows.

This work-around is only needed for Python 3.6 and 3.7. With Python 3.8, `ProactorEventLoop` is already the default on Windows.

## yapapi.log

Utilities for logging computation events via the standard `logging` module.

Functions in this module fall into two categories:

* Functions that convert computation events generated by the `Executor.submit` method to calls to the standard Python `logging` module, using the loggers in the "yapapi" namespace \(e.g. `logging.getLogger("yapapi.executor")`\). These functions should be passed as `event_consumer` arguments to `Executor()`.
* Functions that perform configuration of the `logging` module itself. Since logging configuration is in general a responsibility of the code that uses `yapapi` as a library, we only provide the `enable_default_logger` function in this category, that enables logging to stderr with level `logging.INFO` and, optionally, to a given file with level `logging.DEBUG`.

### Functions for handling events

Several functions from this module can be passed as `event_consumer` callback to `yapapi.Executor()`.

For detailed, human-readable output use the `log_event` function:

```python
    Executor(..., event_consumer=yapapi.log.log_event)
```

For even more detailed, machine-readable output use `log_event_repr`:

```python
    Executor(..., event_consumer=yapapi.log.log_event_repr)
```

For summarized, human-readable output use `log_summary()`:

```python
    Executor(..., event_consumer=yapapi.log.log_summary())
```

Summary output can be combined with a detailed one by passing the detailed logger as an argument to `log_summary`:

```python
    Executor(
        ...
        event_consumer=yapapi.log.log_summary(yapapi.log.log_event_repr)
    )
```

#### enable\_default\_logger

```python
enable_default_logger(format_: str = "[%(asctime)s %(levelname)s %(name)s] %(message)s", log_file: Optional[str] = None, debug_activity_api: bool = False, debug_market_api: bool = False, debug_payment_api: bool = False)
```

Enable the default logger that logs messages to stderr with level `INFO`.

If `log_file` is specified, the logger with output messages with level `DEBUG` to the given file.

#### log\_event

```python
log_event(event: events.Event) -> None
```

Log an event in human-readable representation.

#### log\_event\_repr

```python
log_event_repr(event: events.Event) -> None
```

Log the result of calling `__repr__()` for the `event`.

### SummaryLogger Objects

```python
class SummaryLogger()
```

Aggregates information from computation events to provide a high-level summary.

The logger's `log()` method can be used as `event_consumer` callback to `Executor()`. It will aggregate the events generated by `Executor.submit()` and output some summary information.

The optional `wrapped_emitter` argument can be used for chaining event emitters: each event logged with `log()` is first passed to `wrapped_emitter`.

For example, with the following setup, each event emitted by `executor` will be logged by `log_event_repr`, and additionally, certain events will cause summary messages to be logged.

```python
    detailed_logger = log_event_repr
    summary_logger = SummaryLogger(wrapped_emitter=detailed_logger).log
    executor = Executor(..., event_consumer=summary_logger)
```

#### \_\_init\_\_

```python
 | __init__(wrapped_emitter: Optional[Callable[[events.Event], None]] = None)
```

Create a SummaryLogger.

#### log

```python
 | log(event: events.Event) -> None
```

Register an event.

#### log\_summary

```python
log_summary(wrapped_emitter: Optional[Callable[[events.Event], None]] = None)
```

Output a summary of computation.

This is a utility function that creates a `SummaryLogger` instance wrapping an optional `wrapped_emitter` and returns its `log` method.

See the documentation of `SummaryLogger` for more information.

## yapapi.props

### NodeInfo Objects

```python
@dataclass
class NodeInfo(Model)
```

Properties describing the information regarding the node.

#### name

human-readable name of the Golem node

#### subnet\_tag

the name of the subnet within which the Demands and Offers are matched

### Activity Objects

```python
@dataclass()
class Activity(Model)
```

Activity-related Properties

#### cost\_cap

Sets a Hard cap on total cost of the Activity \(regardless of the usage vector or pricing function\). The Provider is entitled to 'kill' an Activity which exceeds the capped cost amount indicated by Requestor.

#### cost\_warning

Sets a Soft cap on total cost of the Activity \(regardless of the usage vector or pricing function\). When the cost\_warning amount is reached for the Activity, the Provider is expected to send a Debit Note to the Requestor, indicating the current amount due

#### timeout\_secs

A timeout value for batch computation \(eg. used for container-based batch processes\). This property allows to set the timeout to be applied by the Provider when running a batch computation: the Requestor expects the Activity to take no longer than the specified timeout value - which implies that eg. the golem.usage.duration\_sec counter shall not exceed the specified timeout value.

## yapapi.props.builder

### DemandBuilder Objects

```python
class DemandBuilder()
```

Builds a dictionary of properties and constraints from high-level models.

The dictionary represents a Demand object, which is later matched by the new Golem's market implementation against Offers coming from providers to find those providers who can satisfy the requestor's demand.

example usage:

```python
>>> import yapapi
>>> from yapapi import properties as yp
>>> from yapapi.props.builder import DemandBuilder
>>> from datetime import datetime, timezone
>>> builder = DemandBuilder()
>>> builder.add(yp.NodeInfo(name="a node", subnet_tag="testnet"))
>>> builder.add(yp.Activity(expiration=datetime.now(timezone.utc)))
>>> builder.__repr__
>>> print(builder)
{'properties':
    {'golem.node.id.name': 'a node',
     'golem.node.debug.subnet': 'testnet',
     'golem.srv.comp.expiration': 1601655628772},
 'constraints': []}
```

#### properties

```python
 | @property
 | properties() -> dict
```

List of properties for this demand.

#### constraints

```python
 | @property
 | constraints() -> str
```

List of constraints for this demand.

#### ensure

```python
 | ensure(constraint: str)
```

Add a constraint to the demand definition.

**Arguments**:

* `constraint`: a constraint expressed in Golem's property description format.

it may be a simple constraint defining just one property, e.g.: `(golem.node.debug.subnet=community.3)`, `(golem.com.payment.platform.NGNT.address=*)`

or it may be a compound constraint that defines requirements over a set of properties, e.g.: `(&(golem.inf.mem.gib>=0.5) (golem.inf.storage.gib>=2.0) (golem.runtime.name=vm))`

#### add

```python
 | add(m: Model)
```

Add properties from the specified model to this demand definition.

#### subscribe

```python
 | async subscribe(market: Market) -> Subscription
```

Create a Demand on the market and subscribe to Offers that will match that Demand.

## yapapi.props.com

Payment-related properties.

#### SCHEME

the key which defines the billing scheme

#### PRICE\_MODEL

the key which defines the pricing model

#### LINEAR\_COEFFS

the key which defines the pricing model's linear coefficients

#### DEFINED\_USAGES

the key which defines the usages vector

### BillingScheme Objects

```python
class BillingScheme(enum.Enum)
```

Enum of possible billing schemes.

#### PAYU

payment for usage

### PriceModel Objects

```python
class PriceModel(enum.Enum)
```

Enum of possible pricing models.

#### LINEAR

the cost depends linearly on the value it derives from

### Counter Objects

```python
class Counter(enum.Enum)
```

Enum of possible resources, the usage of which is paid for.

#### TIME

execution time

#### CPU

cpu time

#### STORAGE

disk storage

#### MAXMEM

maximum memory usage

#### UNKNOWN

unknown resource

### Com Objects

```python
@dataclass(frozen=True)
class Com(Model)
```

Base model for properties describing various payment models.

### ComLinear Objects

```python
@dataclass(frozen=True)
class ComLinear(Com)
```

Payment model with linear pricing.

## yapapi.props.inf

Infrastructural properties.

#### INF\_MEM

the key which defines the memory requirement

#### INF\_STORAGE

the key which defines the storage requirement

#### INF\_CORES

the key which defines number of required CPU cores

#### TRANSFER\_CAPS

the key which defines the transfer protocol

### RuntimeType Objects

```python
@dataclass
class RuntimeType(Enum)
```

Enum of possible runtime environments.

#### UNKNOWN

Unknown runtime

#### WASMTIME

Wasmtime runtime

#### EMSCRIPTEN

Emscripten runtime

#### VM

VM container runtime

### WasmInterface Objects

```python
@dataclass
class WasmInterface(Enum)
```

Wasi version

#### WASI\_0

0

#### WASI\_0preview1

0preview1

### InfBase Objects

```python
@dataclass
class InfBase(Model)
```

Base model describing the possible runtimes and the related requirements.

#### mem

memory requirement

#### runtime

runtime environment

#### storage

storage requirement

#### transfers

required transfer protocol

### InfVm Objects

```python
@dataclass
class InfVm(InfBase)
```

Model that describes the VM runtime requirement.

#### cores

required number of cores

### ExeUnitRequest Objects

```python
@dataclass
class ExeUnitRequest(Model)
```

Model describing the requirements for an execution unit.

#### package\_url

package used for computation

### VmPackageFormat Objects

```python
class VmPackageFormat(Enum)
```

Enum of possible VM package formats.

#### UNKNOWN

unknown

#### GVMKIT\_SQUASH

gvmkit-build's image format

### VmRequest Objects

```python
@dataclass
class VmRequest(ExeUnitRequest)
```

Requirements for the VM execution unit.

#### package\_format

package format

## yapapi.props.base

### InvalidPropertiesError Objects

```python
class InvalidPropertiesError(Exception)
```

Raised by `Model.from_properties(cls, properties)` when given invalid `properties`.

### Model Objects

```python
class Model(abc.ABC)
```

Base class from which all property models inherit.

Provides helper methods to load the property model data from a dictionary and to get a mapping of all the keys available in the given model.

#### from\_properties

```python
 | @classmethod
 | from_properties(cls: Type[ME], props: Props) -> ME
```

Initialize the model from a dictionary representation.

When provided with a dictionary of properties, it will find the matching keys within it and fill the model fields with the values from the dictionary.

It ignores non-matching keys - i.e. doesn't require filtering of the properties' dictionary before the model is fed with the data. Thus, several models can be initialized from the same dictionary and all models will only load their own data.

#### keys

```python
 | @classmethod
 | keys(cls)
```

**Returns**:

a mapping between the model's field names and the property keys

example:

```python
>>> import dataclasses
>>> import typing
>>> from yapapi.properties.base import Model
>>> @dataclasses.dataclass
... class NodeInfo(Model):
...     name: typing.Optional[str] = \
...     dataclasses.field(default=None, metadata={"key": "golem.node.id.name"})
...
>>> NodeInfo.keys().name
'golem.node.id.name'
```

## yapapi.storage

Storage models.

### OutputStorageProvider Objects

```python
class OutputStorageProvider(abc.ABC)
```

#### new\_destination

```python
 | @abc.abstractmethod
 | async new_destination(destination_file: Optional[PathLike] = None) -> Destination
```

Creates slot for receiving file.

### Parameters

destination\_file: Optional hint where received data should be placed.

## yapapi.storage.webdav

## yapapi.storage.gftp

Golem File Transfer Storage Provider

### PubLink Objects

```python
class PubLink(TypedDict)
```

GFTP linking information.

#### file

file on local filesystem.

#### url

GFTP url as which local files is exposed.

### GftpDriver Objects

```python
class GftpDriver(Protocol)
```

Golem FTP service API.

#### version

```python
 | async version() -> str
```

Gets driver version.

#### publish

```python
 | async publish(*, files: List[str]) -> List[PubLink]
```

Exposes local file as GFTP url.

`files` : local files to be exposed

#### close

```python
 | async close(*, urls: List[str]) -> CommandStatus
```

Stops exposing GFTP urls created by [publish\(files=\[..\]\)](https://github.com/golemfactory/yagna-docs/tree/edc7b39d46329ef7cb8d156cc62c7fd2e32490d2/yapapi/%60publish%60/README.md).

#### receive

```python
 | async receive(*, output_file: str) -> PubLink
```

Creates GFTP url for receiving file.

: `output_file` -

#### shutdown

```python
 | async shutdown() -> CommandStatus
```

Stops GFTP service.

After shutdown all generated urls will be unavailable.

## yapapi.\_cli

## yapapi.\_cli.run

## yapapi.\_cli.market

### Demand Objects

```python
class Demand()
```

Offer subscription management.

#### list

```python
 | @async_run
 | async list(only_expired: bool = False)
```

Lists all active demands

#### clear

```python
 | @async_run
 | async clear(only_expired: bool = False)
```

Removes demands.

By default removes all demands.

**Arguments**:

* `only_expired`: removes only expired demands.

## yapapi.\_cli.payment

### Allocation Objects

```python
class Allocation()
```

Payment allocation management.

#### list

```python
 | @async_run
 | async list(details: bool = False)
```

Lists current active payment allocation

#### clear

```python
 | @async_run
 | async clear()
```

Removes all active payment allocations

### Invoices Objects

```python
class Invoices()
```

Invoice management.

#### accept

```python
 | @async_run
 | async accept(allocation_id: str, invoice_id: str)
```

Accepts given `invoice_id` with `allocation_id`

**Arguments**:

* `allocation_id`: Allocation from which invoice will be paid. see

  `allocation list`.

* `invoice_id`: Invoice identifier.

#### list

```python
 | @async_run
 | async list(by_status: Optional[str] = None)
```

Lists all invoices.

## yapapi.executor

An implementation of the new Golem's task executor.

#### CFG\_INVOICE\_TIMEOUT

Time to receive invoice from provider after tasks ended.

### Executor Objects

```python
class Executor(AsyncContextManager)
```

Task executor.

Used to run tasks using the specified application package within providers' execution units.

#### \_\_init\_\_

```python
 | __init__(*, package: Package, max_workers: int = 5, timeout: timedelta = timedelta(minutes=5), budget: Union[float, Decimal], strategy: MarketStrategy = DummyMS(), subnet_tag: Optional[str] = None, event_consumer: Optional[Callable[[Event], None]] = None)
```

Create a new executor.

**Arguments**:

* `package`: a package common for all tasks; vm.repo\(\) function may be

  used to return package from a repository

* `max_workers`: maximum number of workers doing the computation
* `timeout`: timeout for the whole computation
* `budget`: maximum budget for payments
* `strategy`: market strategy used to select providers from the market

  \(e.g. LeastExpensiveLinearPayuMS or DummyMS\)

* `subnet_tag`: use only providers in the subnet with the subnet\_tag name
* `event_consumer`: a callable that processes events related to the

  computation; by default it is a function that logs all events

#### submit

```python
 | async submit(worker: Callable[[WorkContext, AsyncIterator[Task[D, R]]], AsyncGenerator[Work, None]], data: Iterable[Task[D, R]]) -> AsyncIterator[Task[D, R]]
```

Submit a computation to be executed on providers.

**Arguments**:

* `worker`: a callable that takes a WorkContext object and a list o tasks,

  adds commands to the context object and yields committed commands

* `data`: an iterator of Task objects to be computed on providers

**Returns**:

yields computation progress events

## yapapi.executor.\_smartq

YAPAPI internal module. This is not a part of the public API. It can change at any time.

## yapapi.executor.task

### Task Objects

```python
class Task(Generic[TaskData, TaskResult])
```

One computation unit.

Represents one computation unit that will be run on the provider \(e.g. rendering of one frame of an animation\).

#### \_\_init\_\_

```python
 | __init__(data: TaskData)
```

Create a new Task object.

**Arguments**:

* `data`: contains information needed to prepare command list for the provider

#### running\_time

```python
 | @property
 | running_time() -> Optional[timedelta]
```

Return the running time of the task \(if in progress\) or time it took to complete it.

#### accept\_result

```python
 | accept_result(result: Optional[TaskResult] = None) -> None
```

Accept the result of this task.

Must be called when the result is correct to mark this task as completed.

**Arguments**:

* `result`: task computation result \(optional\)

**Returns**:

None

#### reject\_result

```python
 | reject_result(reason: Optional[str] = None, retry: bool = False) -> None
```

Reject the result of this task.

Must be called when the result is not correct to indicate that the task should be retried.

**Arguments**:

* `reason`: task rejection description \(optional\)

**Returns**:

None

## yapapi.executor.events

Representing events in Golem computation.

### Event Objects

```python
@dataclass(init=False)
class Event()
```

An abstract base class for types of events emitted by `Executor.submit()`.

#### extract\_exc\_info

```python
 | extract_exc_info() -> Tuple[Optional[ExcInfo], "Event"]
```

Extract exception information from this event.

Return the extracted exception information and a copy of the event without the exception information.

### HasExcInfo Objects

```python
@dataclass(init=False)
class HasExcInfo(Event)
```

A base class for types of events that carry an optional exception info.

#### extract\_exc\_info

```python
 | extract_exc_info() -> Tuple[Optional[ExcInfo], "Event"]
```

Return the `exc_info` field and a copy of this event with the field set to `None`.

### ComputationFinished Objects

```python
@dataclass
class ComputationFinished(HasExcInfo)
```

Indicates successful completion if `exc_info` is `None` and a failure otherwise.

### WorkerFinished Objects

```python
@dataclass
class WorkerFinished(HasExcInfo,  AgreementEvent)
```

Indicates successful completion if `exc_info` is `None` and a failure otherwise.

### ShutdownFinished Objects

```python
@dataclass
class ShutdownFinished(HasExcInfo)
```

Indicates the completion of Executor shutdown sequence

## yapapi.executor.strategy

Implementation of strategies for choosing offers from market.

### MarketStrategy Objects

```python
class MarketStrategy(abc.ABC)
```

Abstract market strategy.

#### decorate\_demand

```python
 | async decorate_demand(demand: DemandBuilder) -> None
```

Optionally add relevant constraints to a Demand.

#### score\_offer

```python
 | async score_offer(offer: rest.market.OfferProposal) -> float
```

Score `offer`. Better offers should get higher scores.

### DummyMS Objects

```python
@dataclass
class DummyMS(MarketStrategy,  object)
```

A default market strategy implementation.

Its `score_offer()` method returns `SCORE_NEUTRAL` for every offer with prices that do not exceed maximum prices specified for each counter. For other offers, returns `SCORE_REJECTED`.

#### decorate\_demand

```python
 | async decorate_demand(demand: DemandBuilder) -> None
```

Ensure that the offer uses `PriceModel.LINEAR` price model.

#### score\_offer

```python
 | async score_offer(offer: rest.market.OfferProposal) -> float
```

Score `offer`. Returns either `SCORE_REJECTED` or `SCORE_NEUTRAL`.

### LeastExpensiveLinearPayuMS Objects

```python
@dataclass
class LeastExpensiveLinearPayuMS(MarketStrategy,  object)
```

A strategy that scores offers according to cost for given computation time.

#### decorate\_demand

```python
 | async decorate_demand(demand: DemandBuilder) -> None
```

Ensure that the offer uses `PriceModel.LINEAR` price model.

#### score\_offer

```python
 | async score_offer(offer: rest.market.OfferProposal) -> float
```

Score `offer` according to cost for expected computation time.

## yapapi.executor.utils

Utility functions and classes used within the `yapapi.executor` package.

### AsyncWrapper Objects

```python
class AsyncWrapper()
```

Wraps a given callable to provide asynchronous calls.

Example usage:

with AsyncWrapper\(func\) as wrapper: wrapper.async\_call\("Hello", world=True\) wrapper.async\_call\("Bye!"\)

The above code will make two asynchronous calls to `func`. The results of the calls, if any, are discarded, so this class is most useful for wrapping callables that return `None`.

#### async\_call

```python
 | async_call(*args, **kwargs) -> None
```

Schedule an asynchronous call to the wrapped callable.

## yapapi.executor.ctx

### Work Objects

```python
class Work(abc.ABC)
```

#### prepare

```python
 | async prepare()
```

A hook to be executed on requestor's end before the script is sent to the provider.

#### register

```python
 | register(commands: CommandContainer)
```

A hook which adds the required command to the exescript.

#### post

```python
 | async post()
```

A hook to be executed on requestor's end after the script has finished.

#### timeout

```python
 | @property
 | timeout() -> Optional[timedelta]
```

Return the optional timeout set for execution of this work.

### \_Steps Objects

```python
class _Steps(Work)
```

#### timeout

```python
 | @property
 | timeout() -> Optional[timedelta]
```

Return the optional timeout set for execution of all steps.

#### prepare

```python
 | async prepare()
```

Execute the `prepare` hook for all the defined steps.

#### register

```python
 | register(commands: CommandContainer)
```

Execute the `register` hook for all the defined steps.

#### post

```python
 | async post()
```

Execute the `post` step for all the defined steps.

### WorkContext Objects

```python
class WorkContext()
```

An object used to schedule commands to be sent to provider.

#### send\_json

```python
 | send_json(json_path: str, data: dict)
```

Schedule sending JSON data to the provider.

**Arguments**:

* `json_path`: remote \(provider\) path
* `data`: dictionary representing JSON data

**Returns**:

None

#### send\_file

```python
 | send_file(src_path: str, dst_path: str)
```

Schedule sending file to the provider.

**Arguments**:

* `src_path`: local \(requestor\) path
* `dst_path`: remote \(provider\) path

**Returns**:

None

#### run

```python
 | run(cmd: str, *args: Iterable[str], *, env: Optional[Dict[str, str]] = None)
```

Schedule running a command.

**Arguments**:

* `cmd`: command to run on the provider, e.g. /my/dir/run.sh
* `args`: command arguments, e.g. "input1.txt", "output1.txt"
* `env`: optional dictionary with environmental variables

**Returns**:

None

#### download\_file

```python
 | download_file(src_path: str, dst_path: str)
```

Schedule downloading remote file from the provider.

**Arguments**:

* `src_path`: remote \(provider\) path
* `dst_path`: local \(requestor\) path

**Returns**:

None

#### commit

```python
 | commit(timeout: Optional[timedelta] = None) -> Work
```

Creates sequence of commands to be sent to provider.

**Returns**:

Work object \(the latter contains sequence commands added before calling this method\)

## yapapi.\_\_main\_\_

## yapapi.rest

Mid-level binding for Golem REST API.

Serves as a more convenient interface between the agent code and the REST API.

## yapapi.rest.configuration

### Configuration Objects

```python
class Configuration(object)
```

REST API's setup and top-level access utility.

By default, it expects the yagna daemon to be available locally and listening on the default port. The urls for the specific APIs are then based on this default base URL.

It requires one external argument, namely Yagna's application key, which is used to authenticate with the daemon. The application key must be either specified explicitly using the `app_key` argument or provided by the `YAGNA_APPKEY` environment variable.

If `YAGNA_API_URL` environment variable exists, it will be used as a base URL for all REST API URLs. Example value: [http://127.0.10.10:7500](http://127.0.10.10:7500) \(no trailing slash\).

Other than that, the URLs of each specific REST API can be overridden using the following environment variables:

* `YAGNA_MARKET_URL`
* `YAGNA_PAYMENT_URL`
* `YAGNA_ACTIVITY_URL`

#### app\_key

```python
 | @property
 | app_key() -> str
```

Yagna daemon's application key used to access the REST API.

#### market\_url

```python
 | @property
 | market_url() -> str
```

The URL of the Market REST API

#### payment\_url

```python
 | @property
 | payment_url() -> str
```

The URL of the Payment REST API

#### activity\_url

```python
 | @property
 | activity_url() -> str
```

The URL of the Activity REST API

#### market

```python
 | market() -> ya_market.ApiClient
```

Return a REST client for the Market API.

#### payment

```python
 | payment() -> ya_payment.ApiClient
```

Return a REST client for the Payment API.

#### activity

```python
 | activity() -> ya_activity.ApiClient
```

Return a REST client for the Activity API.

## yapapi.rest.market

### AgreementDetails Objects

```python
class AgreementDetails(object)
```

### View Objects

```python
@dataclass
class View()
```

A certain fragment of an agreement's properties.

#### extract

```python
 | extract(m: Type[_ModelType]) -> _ModelType
```

Extract properties for the given model from this view's properties.

#### provider\_view

```python
 | @property
 | provider_view() -> View
```

Get the view of provider's properties in this Agreement.

#### requestor\_view

```python
 | @property
 | requestor_view() -> View
```

Get the view of requestor's properties in this Agreement.

### Agreement Objects

```python
class Agreement(object)
```

Mid-level interface to the REST's Agreement model.

#### confirm

```python
 | async confirm() -> bool
```

Sign and send the agreement to the provider and then wait for it to be approved.

**Returns**:

True if the agreement has been confirmed, False otherwise

### OfferProposal Objects

```python
class OfferProposal(object)
```

Mid-level interface to handle the negotiation phase between the parties.

#### reject

```python
 | async reject(reason: Optional[str] = None)
```

Reject the Offer.

#### respond

```python
 | async respond(props: dict, constraints: str) -> str
```

Create an agreeement Proposal for a received Offer, based on our Demand.

#### create\_agreement

```python
 | async create_agreement(timeout=timedelta(hours=1)) -> Agreement
```

Create an Agreement based on this Proposal.

### Subscription Objects

```python
class Subscription(object)
```

Mid-level interface to REST API's Subscription model.

#### details

```python
 | @property
 | details() -> models.Demand
```

**Returns**:

the Demand for which the Subscription has been registered.

#### delete

```python
 | async delete()
```

Unsubscribe this Demand from the market.

#### events

```python
 | async events() -> AsyncIterator[OfferProposal]
```

Yield counter-proposals based on the incoming, matching Offers.

### Market Objects

```python
class Market(object)
```

Mid-level interface to the Market REST API.

#### subscribe

```python
 | subscribe(props: dict, constraints: str) -> AsyncResource[Subscription]
```

Create a subscription for a demand specified by the supplied properties and constraints.

#### subscriptions

```python
 | async subscriptions() -> AsyncIterator[Subscription]
```

Yield all the subscriptions that this requestor agent has on the market.

## yapapi.rest.activity

### ActivityService Objects

```python
class ActivityService(object)
```

A convenience helper to facilitate the creation of an Activity.

#### new\_activity

```python
 | async new_activity(agreement_id: str) -> "Activity"
```

Create an activity within bounds of the specified agreement.

**Returns**:

the object that represents the Activity and allows to query and control its state :rtype: Activity

### Activity Objects

```python
class Activity(AsyncContextManager["Activity"])
```

Mid-level wrapper for REST's Activity endpoint

#### state

```python
 | async state() -> yaa.ActivityState
```

Query the state of the activity.

#### send

```python
 | async send(script: List[dict], stream: bool = False, deadline: Optional[datetime] = None)
```

Send the execution script to the provider's execution unit.

### CommandExecutionError Objects

```python
class CommandExecutionError(Exception)
```

An exception that indicates that a command failed on a provider.

#### command

The command that failed.

#### message

The command's output, if any.

### BatchTimeoutError Objects

```python
class BatchTimeoutError(Exception)
```

An exception that indicates that an execution of a batch of commands timed out.

### Batch Objects

```python
class Batch(abc.ABC,  AsyncIterable[events.CommandEventContext])
```

Abstract base class for iterating over events related to a batch running on provider.

#### seconds\_left

```python
 | seconds_left() -> float
```

Return how many seconds are left until the deadline.

#### id

```python
 | @property
 | id()
```

Return the ID of this batch.

### PollingBatch Objects

```python
class PollingBatch(Batch)
```

A `Batch` implementation that polls the server repeatedly for command status.

### StreamingBatch Objects

```python
class StreamingBatch(Batch)
```

A `Batch` implementation that uses event streaming to return command status.

## yapapi.rest.resource

## yapapi.rest.payment

### Allocation Objects

```python
@dataclass
class Allocation(_Link)
```

Payment reservation for task processing.

#### id

Allocation object id

#### amount

Total amount allocated

#### payment\_platform

Payment platform, e.g. NGNT

#### payment\_address

Payment address, e.g. 0x123...

#### expires

Allocation expiration timestamp

### Payment Objects

```python
class Payment(object)
```

#### new\_allocation

```python
 | new_allocation(amount: Decimal, payment_platform: str, payment_address: str, *, expires: Optional[datetime] = None, make_deposit: bool = False) -> ResourceCtx[Allocation]
```

Creates new allocation.

* `amount`:  Allocation amount.
* `expires`: expiration timestamp. by default 30 minutes from now.
* `make_deposit`: \(unimplemented\).

#### allocations

```python
 | async allocations() -> AsyncIterator[Allocation]
```

List all active allocations.

example usage - listing all active allocations:

```python
from yapapi import rest

async def list_allocations(payment_api: rest.Payment):
    async for allocation in payment_api.allocations():
        print(f'''allocation: {allocation.id}
            amount={allocation.amount},
            expires={allocation.expires}''')
```

## yapapi.package

### Package Objects

```python
class Package(abc.ABC)
```

Information on task package to be used for running tasks on providers.

#### resolve\_url

```python
 | @abc.abstractmethod
 | async resolve_url() -> str
```

Return package URL.

#### decorate\_demand

```python
 | @abc.abstractmethod
 | async decorate_demand(demand: DemandBuilder)
```

Add package information to a Demand.

## yapapi.package.vm

#### repo

```python
async repo(*, image_hash: str, min_mem_gib: float = 0.5, min_storage_gib: float = 2.0) -> Package
```

Builds reference to application package.

* _image\_hash_: finds package by its contents hash.
* _min\_mem\_gib_: minimal memory required to execute application code.
* _min\_storage\_gib_ minimal disk storage to execute tasks.

